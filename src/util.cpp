#include "util.hpp"

#include <imgui.h>
#include <glad/glad.h>

#include <string>

// Generated by ChatGPT
bool ImGuiDirection2D(const char* label, glm::vec2& dir, float radius) {
    ImGui::BeginGroup();
    ImGui::Text("%s", label);

    ImVec2 pad = ImGui::GetCursorScreenPos();
    float diameter = radius * 2.0f;
    ImVec2 center = ImVec2(pad.x + radius, pad.y + radius);

    ImGui::InvisibleButton((std::string(label) + "##dirpad").c_str(), ImVec2(diameter, diameter));
    ImDrawList* dl = ImGui::GetWindowDrawList();

    // Hintergrund und Rahmen
    dl->AddCircleFilled(center, radius, IM_COL32(48, 48, 48, 255));
    dl->AddCircle(center, radius, IM_COL32(200, 200, 200, 120), 32, 1.0f);

    // Achsen
    dl->AddLine(ImVec2(center.x - radius, center.y), ImVec2(center.x + radius, center.y), IM_COL32(120, 120, 120, 90));
    dl->AddLine(ImVec2(center.x, center.y - radius), ImVec2(center.x, center.y + radius), IM_COL32(120, 120, 120, 90));

    // Thumb (zeigt aktuelle Richtung)
    glm::vec2 n = (glm::length(dir) > 0.0001f) ? glm::normalize(dir) : glm::vec2(1.0f, 0.0f);
    ImVec2 thumb = ImVec2(center.x + n.x * (radius - 8.0f), center.y - n.y * (radius - 8.0f)); // Y gespiegelt für Bildschirmkoordinaten
    dl->AddCircleFilled(thumb, 6.0f, IM_COL32(240, 120, 80, 255));
    dl->AddLine(center, thumb, IM_COL32(240, 120, 80, 200), 2.0f);

    bool changed = false;
    ImGuiIO& io = ImGui::GetIO();
    if (ImGui::IsItemActive() || ImGui::IsItemHovered()) {
        if (io.MouseDown[0]) {
            ImVec2 m = io.MousePos;
            glm::vec2 delta = glm::vec2(m.x - center.x, center.y - m.y); // y invertiert
            if (glm::length(delta) > 0.0001f) {
                glm::vec2 newDir = glm::normalize(delta);
                if (newDir != dir) {
                    dir = newDir;
                    changed = true;
                }
            }
        }
    }

    ImGui::EndGroup();
    return changed;
}


void SetWireframeMode(bool enable)
{
    if (enable) glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    else glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
}

//void SetWireframeZOffset(bool enable)
//{
//    if (enable) glEnable(GL_POLYGON_OFFSET_LINE);
//    else glDisable(GL_POLYGON_OFFSET_LINE);
//}

void SetFaceCulling(bool enable)
{
    if (enable) glEnable(GL_CULL_FACE);
    else glDisable(GL_CULL_FACE);
}

void SetDepthTest(bool enable)
{
    if (enable) glEnable(GL_DEPTH_TEST);
    else glDisable(GL_DEPTH_TEST);
}

void BlitFramebufferColor(const Framebuffer& src, const Framebuffer& dst)
{
    glBindFramebuffer(GL_READ_FRAMEBUFFER, src.fbo);
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, dst.fbo);
    glBlitFramebuffer(
        0, 0, src.width, src.height,
        0, 0, dst.width, dst.height,
        GL_COLOR_BUFFER_BIT, GL_NEAREST
    );
    Framebuffer::Unbind();
}

void BlitFramebufferDepth(const Framebuffer& src, const Framebuffer& dst)
{
    glBindFramebuffer(GL_READ_FRAMEBUFFER, src.fbo);
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, dst.fbo);
    glBlitFramebuffer(
        0, 0, src.width, src.height,
        0, 0, dst.width, dst.height,
        GL_DEPTH_BUFFER_BIT, GL_NEAREST
    );
    Framebuffer::Unbind();
}

