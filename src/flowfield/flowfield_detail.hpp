// code generated by AI
#pragma once

#define _USE_MATH_DEFINES

#include <Eigen/Core>
#include <Eigen/Geometry>
#include <tiny_obj_loader.h>

#include <unordered_map>
#include <unordered_set>
#include <vector>

namespace flowfield::detail {

  double deg2rad(double d);

  Eigen::Vector3d toV3(const std::vector<tinyobj::real_t>& a, int i);
  Eigen::Vector2d toV2(const std::vector<tinyobj::real_t>& a, int i);

  Eigen::Vector3d safeNormalize(const Eigen::Vector3d& v, double eps = 1e-12);
  Eigen::Vector3d projectToTangent(const Eigen::Vector3d& v, const Eigen::Vector3d& n);

  double clampd(double x, double a, double b);

  struct EdgeKey {
    int a, b;
    bool operator==(const EdgeKey& o) const noexcept { return a == o.a && b == o.b; }
  };

  struct EdgeKeyHash {
    std::size_t operator()(const EdgeKey& k) const noexcept;
  };

  struct SplitKey {
    int v, vt, sg;
    bool operator==(const SplitKey& o) const noexcept { return v == o.v && vt == o.vt && sg == o.sg; }
  };

  struct SplitKeyHash {
    std::size_t operator()(const SplitKey& k) const noexcept;
  };

  struct PairHash {
    std::size_t operator()(const std::pair<int, int>& p) const noexcept;
  };

  struct UvIsland {
    std::vector<int> faceIds;
    Eigen::Vector3d avgU = Eigen::Vector3d::Zero();
    Eigen::Vector3d avgV = Eigen::Vector3d::Zero();
    char chosenAxis = 'U';
  };

  struct TriCorner {
    tinyobj::index_t idx;
    int poly = -1;
    int corner = -1;
  };

  struct Tri {
    TriCorner c0, c1, c2;
    int v0() const { return c0.idx.vertex_index; }
    int v1() const { return c1.idx.vertex_index; }
    int v2() const { return c2.idx.vertex_index; }
  };

  struct SmoothingHandler {
    std::vector<std::unordered_map<int, int>> vTriToSG;

    void compute(int nV_in, const std::vector<Tri>& tris, const std::unordered_set<EdgeKey, EdgeKeyHash>& creaseEdges);

    int getSG(int v, int triIndex) const;
  };

  struct ObjPolys {
    tinyobj::attrib_t attrib;
    std::vector<std::vector<tinyobj::index_t>> polys;
    int nV_in = 0;
    int nVT_in = 0;
  };

  bool loadObjAsPolys(const std::string& objPath, ObjPolys& out);

  int getVT(const tinyobj::index_t& idx, int nVT_in);

  std::vector<std::vector<int>> buildUvNeighbors(const ObjPolys& m);
  std::vector<int> computeFaceIslandsBfs(const std::vector<std::vector<int>>& neighbors);

  std::vector<UvIsland> scoreIslandsAxis(const ObjPolys& m, const std::vector<int>& polyIsland);

  std::vector<Tri> triangulate(const ObjPolys& m);

  void computeTriNormalsAndAreas(
      const ObjPolys& m, const std::vector<Tri>& tris, std::vector<Eigen::Vector3d>& triN, std::vector<double>& triA
  );

  std::unordered_map<EdgeKey, std::pair<int, int>, EdgeKeyHash> buildEdgeToTris(const std::vector<Tri>& tris);

  std::unordered_set<EdgeKey, EdgeKeyHash> computeCreaseEdges(
      const std::unordered_map<EdgeKey, std::pair<int, int>, EdgeKeyHash>& edgeToTris,
      const std::vector<Eigen::Vector3d>& triN,
      double creaseThresholdAngleDeg
  );

  struct SplitMesh {
    std::vector<Eigen::Vector3d> outPos;
    std::vector<std::vector<int>> outFaces;
    std::vector<std::vector<int>> polyOutCorner;
  };

  SplitMesh buildSplitMesh(
      const ObjPolys& m,
      const std::vector<Tri>& tris,
      const std::unordered_set<EdgeKey, EdgeKeyHash>& creaseEdges,
      double creaseThresholdAngleDeg
  );

  std::vector<std::vector<int>> buildAdjacencyVec(const std::vector<std::vector<int>>& outFaces, int nV_out);

  void accumulateNormalsAndTangents(
      const ObjPolys& m,
      const std::vector<Tri>& tris,
      const std::vector<int>& polyIsland,
      const std::vector<UvIsland>& islands,
      char axisSetting,
      const std::vector<Eigen::Vector3d>& triN,
      const std::vector<double>& triA,
      const std::vector<std::vector<int>>& polyOutCorner,
      int nV_out,
      std::vector<Eigen::Vector3d>& vNormal,
      std::vector<Eigen::Vector3d>& vTangent,
      std::vector<double>& vWeight
  );

  std::vector<Eigen::Vector3d> buildFlowFromAccum(
      const std::vector<Eigen::Vector3d>& vNormal,
      const std::vector<Eigen::Vector3d>& vTangent,
      const std::vector<double>& vWeight,
      const std::vector<std::vector<int>>& adj
  );

  void packInterleavedVertices(
      const std::vector<Eigen::Vector3d>& outPos,
      const std::vector<Eigen::Vector3d>& outFlow,
      std::vector<float>& outVert
  );

  void packTriangleIndices(const std::vector<std::vector<int>>& polyOutCorner, std::vector<unsigned int>& outInd);

} // namespace flowfield::detail
