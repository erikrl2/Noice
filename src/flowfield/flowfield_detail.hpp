// This code is generated by AI
#pragma once

#define _USE_MATH_DEFINES

#include <Eigen/Core>
#include <Eigen/Geometry>
#include <tiny_obj_loader.h>

#include <unordered_map>
#include <unordered_set>
#include <vector>

namespace flowfield::detail {

  // --------------------- small math utils ---------------------

  double deg2rad(double d);

  Eigen::Vector3d toV3(const std::vector<tinyobj::real_t>& a, int i);
  Eigen::Vector2d toV2(const std::vector<tinyobj::real_t>& a, int i);

  Eigen::Vector3d safeNormalize(const Eigen::Vector3d& v, double eps = 1e-12);
  Eigen::Vector3d projectToTangent(const Eigen::Vector3d& v, const Eigen::Vector3d& n);

  double clampd(double x, double a, double b);

  // --------------------- hash keys ---------------------

  struct EdgeKey {
    int a, b;
    bool operator==(const EdgeKey& o) const noexcept { return a == o.a && b == o.b; }
  };

  struct EdgeKeyHash {
    std::size_t operator()(const EdgeKey& k) const noexcept;
  };

  struct SplitKey {
    int v, vt, sg;
    bool operator==(const SplitKey& o) const noexcept { return v == o.v && vt == o.vt && sg == o.sg; }
  };

  struct SplitKeyHash {
    std::size_t operator()(const SplitKey& k) const noexcept;
  };

  // For unordered_map key: (polyId, corner)
  struct PairHash {
    std::size_t operator()(const std::pair<int, int>& p) const noexcept;
  };

  // --------------------- UV islands ---------------------

  struct UvIsland {
    std::vector<int> faceIds;
    Eigen::Vector3d avgU = Eigen::Vector3d::Zero();
    Eigen::Vector3d avgV = Eigen::Vector3d::Zero();
    char chosenAxis = 'U'; // 'U' or 'V'
  };

  // --------------------- triangulation view ---------------------

  struct TriCorner {
    tinyobj::index_t idx;
    int poly = -1;
    int corner = -1;
  };

  struct Tri {
    TriCorner c0, c1, c2;
    int v0() const { return c0.idx.vertex_index; }
    int v1() const { return c1.idx.vertex_index; }
    int v2() const { return c2.idx.vertex_index; }
  };

  // --------------------- smoothing groups ---------------------

  struct SmoothingHandler {
    // vTriToSG[v][triIndex] -> smoothingGroupId
    std::vector<std::unordered_map<int, int>> vTriToSG;

    void compute(int nV_in, const std::vector<Tri>& tris, const std::unordered_set<EdgeKey, EdgeKeyHash>& creaseEdges);

    int getSG(int v, int triIndex) const;
  };

  // --------------------- pipeline types ---------------------

  struct ObjPolys {
    // OWNS attrib data to avoid dangling refs (ObjReader lives only inside load function)
    tinyobj::attrib_t attrib;
    std::vector<std::vector<tinyobj::index_t>> polys;
    int nV_in = 0;
    int nVT_in = 0;
  };

  // Load OBJ and build polygon list (non-triangulated polys).
  bool loadObjAsPolys(const std::string& objPath, ObjPolys& out);

  // Get texcoord index, validated against [0, nVT_in).
  int getVT(const tinyobj::index_t& idx, int nVT_in);

  // UV adjacency and island labeling.
  std::vector<std::vector<int>> buildUvNeighbors(const ObjPolys& m);
  std::vector<int> computeFaceIslandsBfs(const std::vector<std::vector<int>>& neighbors);

  // Score U/V per island and decide chosen axis.
  std::vector<UvIsland> scoreIslandsAxis(const ObjPolys& m, const std::vector<int>& polyIsland);

  // Triangulate polygon list to internal tris (fan triangulation).
  std::vector<Tri> triangulate(const ObjPolys& m);

  // Compute triangle normals and areas.
  void computeTriNormalsAndAreas(
      const ObjPolys& m, const std::vector<Tri>& tris, std::vector<Eigen::Vector3d>& triN, std::vector<double>& triA
  );

  // Build triangle adjacency by edges: edge -> (t0, t1). Uses -1 for missing.
  std::unordered_map<EdgeKey, std::pair<int, int>, EdgeKeyHash> buildEdgeToTris(const std::vector<Tri>& tris);

  // Compute crease edges based on threshold angle (deg). If <= 0 => empty.
  std::unordered_set<EdgeKey, EdgeKeyHash> computeCreaseEdges(
      const std::unordered_map<EdgeKey, std::pair<int, int>, EdgeKeyHash>& edgeToTris,
      const std::vector<Eigen::Vector3d>& triN,
      double creaseThresholdAngleDeg
  );

  // Build output split vertices + faces.
  struct SplitMesh {
    std::vector<Eigen::Vector3d> outPos; // nV_out
    std::vector<std::vector<int>> outFaces; // per poly: out vertex indices
    std::vector<std::vector<int>> polyOutCorner; // same as outFaces; explicit name for later steps
  };

  SplitMesh buildSplitMesh(
      const ObjPolys& m,
      const std::vector<Tri>& tris,
      const std::unordered_set<EdgeKey, EdgeKeyHash>& creaseEdges,
      double creaseThresholdAngleDeg
  );

  // Build vertex adjacency from polygon faces.
  // PERFORMANCE: we return vector<vector<int>> (no hash). Duplicates are avoided in construction.
  std::vector<std::vector<int>> buildAdjacencyVec(const std::vector<std::vector<int>>& outFaces, int nV_out);

  // Accumulate vertex normals + tangents (using U/V or auto-per-island).
  void accumulateNormalsAndTangents(
      const ObjPolys& m,
      const std::vector<Tri>& tris,
      const std::vector<int>& polyIsland,
      const std::vector<UvIsland>& islands,
      char axisSetting, // 'U'/'V'/'A'
      const std::vector<Eigen::Vector3d>& triN,
      const std::vector<double>& triA,
      const std::vector<std::vector<int>>& polyOutCorner,
      std::vector<Eigen::Vector3d>& vNormal, // out
      std::vector<Eigen::Vector3d>& vTangent, // out (accumulated)
      std::vector<double>& vWeight // out
  );

  // Normalize flow and fill invalid entries.
  std::vector<Eigen::Vector3d> buildFlowFromAccum(
      const std::vector<Eigen::Vector3d>& vNormal,
      const std::vector<Eigen::Vector3d>& vTangent,
      const std::vector<double>& vWeight,
      const std::vector<std::vector<int>>& adj
  );

  // Pack final vertex and index buffers.
  void packInterleavedVertices(
      const std::vector<Eigen::Vector3d>& outPos,
      const std::vector<Eigen::Vector3d>& outFlow,
      std::vector<float>& outVert
  );

  void packTriangleIndices(const std::vector<std::vector<int>>& polyOutCorner, std::vector<unsigned int>& outInd);

} // namespace flowfield::detail
