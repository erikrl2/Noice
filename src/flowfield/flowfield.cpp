// This code is generated by AI
#include "flowfield.hpp"

#include "flowfield_detail.hpp"

bool ComputeUvFlowfieldFromOBJ(
    const std::string& objPath,
    std::vector<float>& outVert,
    std::vector<unsigned int>& outInd,
    const FlowfieldSettings& settings
) {
  using namespace flowfield::detail;

  ObjPolys mesh;
  if (!loadObjAsPolys(objPath, mesh)) return false;

  // 1) UV islands (for 'A'uto axis mode)
  auto neighbors = buildUvNeighbors(mesh);
  auto polyIsland = computeFaceIslandsBfs(neighbors);
  auto islands = scoreIslandsAxis(mesh, polyIsland);

  // 2) Triangulation view and triangle geometry
  auto tris = triangulate(mesh);

  std::vector<Eigen::Vector3d> triN;
  std::vector<double> triA;
  computeTriNormalsAndAreas(mesh, tris, triN, triA);

  // 3) Creases and splitting
  auto edgeToTris = buildEdgeToTris(tris);
  auto creaseEdges = computeCreaseEdges(edgeToTris, triN, settings.creaseThresholdAngle);

  SplitMesh split = buildSplitMesh(mesh, tris, creaseEdges, settings.creaseThresholdAngle);
  const int nV_out = (int)split.outPos.size();

  // 4) Adjacency for filling (vector-based, no hash)
  auto adj = buildAdjacencyVec(split.outFaces, nV_out);

  // 5) Accumulate normals + tangents, then build flow field
  std::vector<Eigen::Vector3d> vNormal, vTangent;
  std::vector<double> vWeight;
  accumulateNormalsAndTangents(
      mesh, tris, polyIsland, islands, settings.axis, triN, triA, split.polyOutCorner, vNormal, vTangent, vWeight
  );

  auto outFlow = buildFlowFromAccum(vNormal, vTangent, vWeight, adj);

  // 6) Pack output buffers
  packInterleavedVertices(split.outPos, outFlow, outVert);
  packTriangleIndices(split.polyOutCorner, outInd);

  return true;
}
