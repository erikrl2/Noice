// code generated by AI
#include "flowfield.hpp"

#include "flowfield_detail.hpp"

bool ComputeUvFlowfieldFromOBJ(
    const std::string& objPath,
    std::vector<float>& outVert,
    std::vector<unsigned int>& outInd,
    const FlowfieldSettings& settings
) {
  using namespace flowfield::detail;

  ObjPolys mesh;
  if (!loadObjAsPolys(objPath, mesh)) return false;

  std::vector<int> polyIsland;
  std::vector<UvIsland> islands;
  if (settings.axis == 'A') {
    auto neighbors = buildUvNeighbors(mesh);
    polyIsland = computeFaceIslandsBfs(neighbors);
    islands = scoreIslandsAxis(mesh, polyIsland);
  }

  auto tris = triangulate(mesh);

  std::vector<Eigen::Vector3d> triN;
  std::vector<double> triA;
  computeTriNormalsAndAreas(mesh, tris, triN, triA);

  auto edgeToTris = buildEdgeToTris(tris);
  auto creaseEdges = computeCreaseEdges(edgeToTris, triN, settings.creaseThresholdAngle);

  SplitMesh split = buildSplitMesh(mesh, tris, creaseEdges, settings.creaseThresholdAngle);
  const int nV_out = (int)split.outPos.size();

  auto adj = buildAdjacencyVec(split.outFaces, nV_out);

  std::vector<Eigen::Vector3d> vNormal, vTangent;
  std::vector<double> vWeight;
  accumulateNormalsAndTangents(
      mesh, tris, polyIsland, islands, settings.axis, triN, triA, split.polyOutCorner, nV_out, vNormal, vTangent, vWeight
  );

  auto outFlow = buildFlowFromAccum(vNormal, vTangent, vWeight, adj);

  packInterleavedVertices(split.outPos, outFlow, outVert);
  packTriangleIndices(split.polyOutCorner, outInd);

  return true;
}
