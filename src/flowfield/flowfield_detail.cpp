// code generated by AI
#include "flowfield_detail.hpp"

#include <algorithm>
#include <cmath>
#include <cstdint>
#include <iostream>
#include <queue>

namespace flowfield::detail {

  double deg2rad(double d) {
    return d * M_PI / 180.0;
  }

  Eigen::Vector3d toV3(const std::vector<tinyobj::real_t>& a, int i) {
    assert(i >= 0 && (size_t)3 * (size_t)i + 2 < a.size());
    const size_t base = (size_t)3 * (size_t)i;
    return Eigen::Vector3d((double)a[base + 0], (double)a[base + 1], (double)a[base + 2]);
  }
  Eigen::Vector2d toV2(const std::vector<tinyobj::real_t>& a, int i) {
    assert(i >= 0 && (size_t)2 * (size_t)i + 1 < a.size());
    const size_t base = (size_t)2 * (size_t)i;
    return Eigen::Vector2d((double)a[base + 0], (double)a[base + 1]);
  }

  Eigen::Vector3d safeNormalize(const Eigen::Vector3d& v, double eps) {
    double n = v.norm();
    return (n < eps) ? Eigen::Vector3d(0, 0, 0) : v / n;
  }
  Eigen::Vector3d projectToTangent(const Eigen::Vector3d& v, const Eigen::Vector3d& n) {
    return v - v.dot(n) * n;
  }
  double clampd(double x, double a, double b) {
    return std::max(a, std::min(b, x));
  }

  std::size_t EdgeKeyHash::operator()(const EdgeKey& k) const noexcept {
    uint64_t a = (uint32_t)k.a;
    uint64_t b = (uint32_t)k.b;
    uint64_t x = (a << 32) ^ b;
    x ^= (x >> 33);
    x *= 0xff51afd7ed558ccdULL;
    x ^= (x >> 33);
    x *= 0xc4ceb9fe1a85ec53ULL;
    x ^= (x >> 33);
    return (size_t)x;
  }

  std::size_t SplitKeyHash::operator()(const SplitKey& k) const noexcept {
    uint64_t a = (uint32_t)k.v;
    uint64_t b = (uint32_t)(k.vt + 1);
    uint64_t c = (uint32_t)k.sg;
    uint64_t x = (a * 1315423911ULL) ^ (b * 2654435761ULL) ^ (c * 97531ULL);
    x ^= (x >> 33);
    x *= 0xff51afd7ed558ccdULL;
    x ^= (x >> 33);
    x *= 0xc4ceb9fe1a85ec53ULL;
    x ^= (x >> 33);
    return (size_t)x;
  }

  std::size_t PairHash::operator()(const std::pair<int, int>& p) const noexcept {
    return std::hash<int>()(p.first) ^ (std::hash<int>()(p.second) << 1);
  }

  bool loadObjAsPolys(const std::string& objPath, ObjPolys& out) {
    tinyobj::ObjReaderConfig cfg;
    cfg.triangulate = false;

    tinyobj::ObjReader reader;
    if (!reader.ParseFromFile(objPath, cfg)) {
      std::cerr << "Failed to read OBJ: " << objPath << "\n";
      return false;
    }

    out.attrib = reader.GetAttrib();
    const auto& shapes = reader.GetShapes();

    out.nV_in = (int)(out.attrib.vertices.size() / 3);
    out.nVT_in = (int)(out.attrib.texcoords.size() / 2);

    if (out.nV_in <= 0 || out.nVT_in <= 0) {
      std::cerr << "OBJ must have positions and texcoords\n";
      return false;
    }

    out.polys.clear();
    out.polys.reserve(shapes.size() * 16);

    for (const auto& sh : shapes) {
      size_t index_offset = 0;
      for (size_t f = 0; f < sh.mesh.num_face_vertices.size(); f++) {
        int fv = sh.mesh.num_face_vertices[f];
        if (fv < 3) {
          index_offset += (size_t)fv;
          continue;
        }
        std::vector<tinyobj::index_t> poly;
        poly.reserve((size_t)fv);
        for (int k = 0; k < fv; k++) poly.push_back(sh.mesh.indices[index_offset + (size_t)k]);
        out.polys.push_back(std::move(poly));
        index_offset += (size_t)fv;
      }
    }

    return true;
  }

  int getVT(const tinyobj::index_t& idx, int nVT_in) {
    int vt = idx.texcoord_index;
    assert(vt >= 0 && vt < nVT_in);
    return vt;
  }

  using FaceVertexToVt = std::vector<std::pair<int, int>>; // (v -> vt), sorted by v

  static inline int findVt(const FaceVertexToVt& face, int v) {
    auto it = std::lower_bound(face.begin(), face.end(), v, [](const std::pair<int, int>& a, int value) {
      return a.first < value;
    });
    assert(it != face.end() && it->first == v);
    return it->second;
  }

  static std::vector<FaceVertexToVt> buildFaceVertexToVt(const ObjPolys& m) {
    std::vector<FaceVertexToVt> map(m.polys.size());

    for (size_t p = 0; p < m.polys.size(); ++p) {
      const auto& poly = m.polys[p];
      auto& out = map[p];
      out.reserve(poly.size());

      for (const auto& idx : poly) {
        out.emplace_back(idx.vertex_index, getVT(idx, m.nVT_in));
      }

      std::sort(out.begin(), out.end(), [](const auto& a, const auto& b) { return a.first < b.first; });

      for (size_t r = 1; r < out.size(); ++r) {
        assert(out[r - 1].first != out[r].first);
      }
    }

    return map;
  }

  std::vector<std::vector<int>> buildUvNeighbors(const ObjPolys& m) {
    std::vector<std::vector<int>> polyNeighbors(m.polys.size());

    std::unordered_map<EdgeKey, int, EdgeKeyHash> edgeToFace;
    edgeToFace.reserve(m.polys.size() * 4);

    const auto faceVt = buildFaceVertexToVt(m);

    for (int p = 0; p < (int)m.polys.size(); ++p) {
      const auto& poly = m.polys[(size_t)p];
      const int fv = (int)poly.size();

      for (int i = 0; i < fv; ++i) {
        const int vA = poly[(size_t)i].vertex_index;
        const int vB = poly[(size_t)((i + 1) % fv)].vertex_index;
        const EdgeKey ekey{std::min(vA, vB), std::max(vA, vB)};

        auto it = edgeToFace.find(ekey);
        if (it == edgeToFace.end()) {
          edgeToFace.emplace(ekey, p);
          continue;
        }

        const int nb = it->second;

        const int a0 = findVt(faceVt[(size_t)p], vA);
        const int a1 = findVt(faceVt[(size_t)p], vB);
        const int b0 = findVt(faceVt[(size_t)nb], vA);
        const int b1 = findVt(faceVt[(size_t)nb], vB);

        if (a0 < 0 || a1 < 0 || b0 < 0 || b1 < 0) continue;

        if (a0 == b0 && a1 == b1) {
          polyNeighbors[(size_t)p].push_back(nb);
          polyNeighbors[(size_t)nb].push_back(p);
        }
      }
    }

    return polyNeighbors;
  }

  std::vector<int> computeFaceIslandsBfs(const std::vector<std::vector<int>>& neighbors) {
    std::vector<int> polyIsland(neighbors.size(), -1);
    int nextId = 0;

    for (int start = 0; start < (int)neighbors.size(); ++start) {
      if (polyIsland[(size_t)start] != -1) continue;

      std::queue<int> q;
      q.push(start);
      polyIsland[(size_t)start] = nextId;

      while (!q.empty()) {
        int f = q.front();
        q.pop();
        for (int nb : neighbors[(size_t)f]) {
          if (polyIsland[(size_t)nb] == -1) {
            polyIsland[(size_t)nb] = nextId;
            q.push(nb);
          }
        }
      }
      nextId++;
    }

    return polyIsland;
  }

  std::vector<UvIsland> scoreIslandsAxis(const ObjPolys& m, const std::vector<int>& polyIsland) {
    int islandCount = 0;
    for (int id : polyIsland) islandCount = std::max(islandCount, id + 1);

    std::vector<UvIsland> islands((size_t)islandCount);
    for (int f = 0; f < (int)polyIsland.size(); ++f) {
      int iid = polyIsland[(size_t)f];
      if (iid >= 0) islands[(size_t)iid].faceIds.push_back(f);
    }

    const auto& attrib = m.attrib;

    for (auto& isl : islands) {
      Eigen::Vector3d sumU = Eigen::Vector3d::Zero(), sumV = Eigen::Vector3d::Zero();
      double sumUlen = 0.0, sumVlen = 0.0;

      for (int faceid : isl.faceIds) {
        const auto& poly = m.polys[(size_t)faceid];
        int fv = (int)poly.size();

        // Fan triangulation for scoring
        for (int i = 1; i < fv - 1; ++i) {
          int v[3], vt[3];
          v[0] = poly[0].vertex_index;
          vt[0] = getVT(poly[0], m.nVT_in);
          v[1] = poly[(size_t)i].vertex_index;
          vt[1] = getVT(poly[(size_t)i], m.nVT_in);
          v[2] = poly[(size_t)(i + 1)].vertex_index;
          vt[2] = getVT(poly[(size_t)(i + 1)], m.nVT_in);

          if (v[0] < 0 || v[1] < 0 || v[2] < 0 || vt[0] < 0 || vt[1] < 0 || vt[2] < 0) continue;
          if (v[0] >= m.nV_in || v[1] >= m.nV_in || v[2] >= m.nV_in) continue;

          Eigen::Vector3d p0 = toV3(attrib.vertices, v[0]);
          Eigen::Vector3d p1 = toV3(attrib.vertices, v[1]);
          Eigen::Vector3d p2 = toV3(attrib.vertices, v[2]);

          Eigen::Vector3d n = (p1 - p0).cross(p2 - p0);
          if (n.norm() < 1e-8) continue;
          n.normalize();

          Eigen::Vector2d w0 = toV2(attrib.texcoords, vt[0]);
          Eigen::Vector2d w1 = toV2(attrib.texcoords, vt[1]);
          Eigen::Vector2d w2 = toV2(attrib.texcoords, vt[2]);

          Eigen::Vector3d e1 = p1 - p0, e2 = p2 - p0;
          Eigen::Vector2d d1 = w1 - w0, d2 = w2 - w0;

          double denom = d1.x() * d2.y() - d2.x() * d1.y();
          if (std::abs(denom) < 1e-20) continue;

          double r = 1.0 / denom;
          Eigen::Vector3d dPdu = (e1 * d2.y() - e2 * d1.y()) * r;
          Eigen::Vector3d dPdv = (e2 * d1.x() - e1 * d2.x()) * r;

          dPdu = projectToTangent(dPdu, n);
          dPdv = projectToTangent(dPdv, n);

          double ulen = dPdu.norm();
          double vlen = dPdv.norm();

          if (ulen > 1e-8) {
            sumU += dPdu;
            sumUlen += ulen;
          }
          if (vlen > 1e-8) {
            sumV += dPdv;
            sumVlen += vlen;
          }
        }
      }

      isl.avgU = (sumUlen > 1e-8) ? Eigen::Vector3d(sumU / sumUlen) : Eigen::Vector3d::Zero();
      isl.avgV = (sumVlen > 1e-8) ? Eigen::Vector3d(sumV / sumVlen) : Eigen::Vector3d::Zero();
      isl.chosenAxis = (sumUlen > sumVlen) ? 'U' : 'V';
    }

    return islands;
  }

  std::vector<Tri> triangulate(const ObjPolys& m) {
    std::vector<Tri> tris;
    tris.reserve(m.polys.size() * 2);

    for (int p = 0; p < (int)m.polys.size(); ++p) {
      const auto& poly = m.polys[(size_t)p];
      int fv = (int)poly.size();
      for (int i = 1; i < fv - 1; ++i) {
        Tri t;
        t.c0 = {poly[0], p, 0};
        t.c1 = {poly[(size_t)i], p, i};
        t.c2 = {poly[(size_t)(i + 1)], p, i + 1};
        tris.push_back(t);
      }
    }
    return tris;
  }

  void computeTriNormalsAndAreas(
      const ObjPolys& m, const std::vector<Tri>& tris, std::vector<Eigen::Vector3d>& triN, std::vector<double>& triA
  ) {
    const auto& attrib = m.attrib;
    triN.resize(tris.size());
    triA.resize(tris.size());

    for (size_t ti = 0; ti < tris.size(); ++ti) {
      const Tri& t = tris[ti];
      if (t.v0() < 0 || t.v1() < 0 || t.v2() < 0 || t.v0() >= m.nV_in || t.v1() >= m.nV_in || t.v2() >= m.nV_in) {
        triN[ti] = Eigen::Vector3d(0, 0, 0);
        triA[ti] = 0.0;
        continue;
      }

      Eigen::Vector3d p0 = toV3(attrib.vertices, t.v0());
      Eigen::Vector3d p1 = toV3(attrib.vertices, t.v1());
      Eigen::Vector3d p2 = toV3(attrib.vertices, t.v2());

      Eigen::Vector3d nraw = (p1 - p0).cross(p2 - p0);
      double dblA = nraw.norm();
      if (dblA < 1e-20) {
        triN[ti] = Eigen::Vector3d(0, 0, 0);
        triA[ti] = 0.0;
        continue;
      }

      triN[ti] = nraw / dblA;
      triA[ti] = 0.5 * dblA;
    }
  }

  std::unordered_map<EdgeKey, std::pair<int, int>, EdgeKeyHash> buildEdgeToTris(const std::vector<Tri>& tris) {
    std::unordered_map<EdgeKey, std::pair<int, int>, EdgeKeyHash> edgeToTris;
    edgeToTris.reserve(tris.size() * 2);

    auto add = [&](int ti, int a, int b) {
      EdgeKey ek{std::min(a, b), std::max(a, b)};
      auto it = edgeToTris.find(ek);
      if (it == edgeToTris.end()) {
        edgeToTris.emplace(ek, std::make_pair(ti, -1));
        return;
      }
      if (it->second.second == -1) it->second.second = ti;
    };

    for (int ti = 0; ti < (int)tris.size(); ++ti) {
      const Tri& t = tris[(size_t)ti];
      add(ti, t.v0(), t.v1());
      add(ti, t.v1(), t.v2());
      add(ti, t.v2(), t.v0());
    }

    return edgeToTris;
  }

  std::unordered_set<EdgeKey, EdgeKeyHash> computeCreaseEdges(
      const std::unordered_map<EdgeKey, std::pair<int, int>, EdgeKeyHash>& edgeToTris,
      const std::vector<Eigen::Vector3d>& triN,
      double creaseThresholdAngleDeg
  ) {
    std::unordered_set<EdgeKey, EdgeKeyHash> creaseEdges;
    if (creaseThresholdAngleDeg <= 0.0) return creaseEdges;

    creaseEdges.reserve(edgeToTris.size() / 2);

    double thresh = deg2rad(creaseThresholdAngleDeg);

    for (const auto& kv : edgeToTris) {
      const EdgeKey& e = kv.first;
      int t0 = kv.second.first;
      int t1 = kv.second.second;
      if (t0 < 0 || t1 < 0) continue;

      const Eigen::Vector3d& n0 = triN[(size_t)t0];
      const Eigen::Vector3d& n1 = triN[(size_t)t1];
      if (n0.norm() < 1e-12 || n1.norm() < 1e-12) continue;

      double ang = std::acos(clampd(n0.dot(n1), -1.0, 1.0));
      if (ang > thresh) creaseEdges.insert(e);
    }

    return creaseEdges;
  }

  void SmoothingHandler::compute(
      int nV_in, const std::vector<Tri>& tris, const std::unordered_set<EdgeKey, EdgeKeyHash>& creaseEdges
  ) {
    vTriToSG.resize((size_t)nV_in);

    std::vector<std::vector<int>> incident((size_t)nV_in);
    for (int ti = 0; ti < (int)tris.size(); ++ti) {
      const Tri& t = tris[(size_t)ti];
      if (t.v0() >= 0) incident[(size_t)t.v0()].push_back(ti);
      if (t.v1() >= 0) incident[(size_t)t.v1()].push_back(ti);
      if (t.v2() >= 0) incident[(size_t)t.v2()].push_back(ti);
    }

    auto isNonCreaseEdgeFromV = [&](int v, int x) {
      EdgeKey ek{std::min(v, x), std::max(v, x)};
      return creaseEdges.find(ek) == creaseEdges.end();
    };

    auto connected = [&](int v, int ta, int tb) -> bool {
      const Tri& A = tris[(size_t)ta];
      const Tri& B = tris[(size_t)tb];

      int an1 = -1, an2 = -1, bn1 = -1, bn2 = -1;

      if (A.v0() == v) {
        an1 = A.v1();
        an2 = A.v2();
      } else if (A.v1() == v) {
        an1 = A.v0();
        an2 = A.v2();
      } else if (A.v2() == v) {
        an1 = A.v0();
        an2 = A.v1();
      } else {
        return false;
      }

      if (B.v0() == v) {
        bn1 = B.v1();
        bn2 = B.v2();
      } else if (B.v1() == v) {
        bn1 = B.v0();
        bn2 = B.v2();
      } else if (B.v2() == v) {
        bn1 = B.v0();
        bn2 = B.v1();
      } else {
        return false;
      }

      if (an1 == bn1 || an1 == bn2) return isNonCreaseEdgeFromV(v, an1);
      if (an2 == bn1 || an2 == bn2) return isNonCreaseEdgeFromV(v, an2);
      return false;
    };

    for (int v = 0; v < nV_in; ++v) {
      const auto& inc = incident[(size_t)v];
      if (inc.empty()) continue;

      auto& triToSg = vTriToSG[(size_t)v];
      triToSg.reserve(inc.size());

      int nextSg = 0;

      for (int tStart : inc) {
        if (triToSg.count(tStart)) continue;

        int sg = nextSg++;
        std::queue<int> q;
        q.push(tStart);
        triToSg[tStart] = sg;

        while (!q.empty()) {
          int ta = q.front();
          q.pop();
          for (int tb : inc) {
            if (triToSg.count(tb)) continue;
            if (connected(v, ta, tb)) {
              triToSg[tb] = sg;
              q.push(tb);
            }
          }
        }
      }
    }
  }

  int SmoothingHandler::getSG(int v, int triIndex) const {
    if (v < 0 || v >= (int)vTriToSG.size()) return 0;
    const auto& m = vTriToSG[(size_t)v];
    auto it = m.find(triIndex);
    if (it == m.end()) return 0;
    return it->second;
  }

  SplitMesh buildSplitMesh(
      const ObjPolys& m,
      const std::vector<Tri>& tris,
      const std::unordered_set<EdgeKey, EdgeKeyHash>& creaseEdges,
      double creaseThresholdAngleDeg
  ) {
    const auto& attrib = m.attrib;

    SmoothingHandler sh;
    const bool splitByCrease = (creaseThresholdAngleDeg > 0.0);
    if (splitByCrease) sh.compute(m.nV_in, tris, creaseEdges);

    std::unordered_map<std::pair<int, int>, int, PairHash> cornerToSG;
    if (splitByCrease) {
      cornerToSG.reserve(tris.size() * 2);
      for (size_t ti = 0; ti < tris.size(); ++ti) {
        const Tri& t = tris[ti];
        cornerToSG[{t.c0.poly, t.c0.corner}] = sh.getSG(t.v0(), (int)ti);
        cornerToSG[{t.c1.poly, t.c1.corner}] = sh.getSG(t.v1(), (int)ti);
        cornerToSG[{t.c2.poly, t.c2.corner}] = sh.getSG(t.v2(), (int)ti);
      }
    }

    std::unordered_map<SplitKey, int, SplitKeyHash> splitMap;
    splitMap.reserve(m.polys.size() * 3);

    std::vector<Eigen::Vector3d> outPos;
    outPos.reserve(m.polys.size() * 3);

    std::vector<std::vector<int>> outFaces(m.polys.size());
    std::vector<std::vector<int>> polyOutCorner(m.polys.size());

    auto getOrCreateOut = [&](int vin, int vt, int sg) {
      SplitKey key{vin, vt, sg};
      auto it = splitMap.find(key);
      if (it != splitMap.end()) return it->second;
      int idx = (int)outPos.size();
      outPos.push_back(toV3(attrib.vertices, vin));
      splitMap.emplace(key, idx);
      return idx;
    };

    for (int p = 0; p < (int)m.polys.size(); ++p) {
      const auto& poly = m.polys[(size_t)p];
      int fv = (int)poly.size();
      outFaces[(size_t)p].resize((size_t)fv);
      polyOutCorner[(size_t)p].resize((size_t)fv);

      for (int k = 0; k < fv; ++k) {
        const tinyobj::index_t& idx = poly[(size_t)k];
        int vin = idx.vertex_index;
        int vt = getVT(idx, m.nVT_in);
        int sg = 0;
        if (splitByCrease) {
          auto it = cornerToSG.find({p, k});
          sg = (it != cornerToSG.end()) ? it->second : 0;
        }
        int idxOut = getOrCreateOut(vin, vt, sg);
        outFaces[(size_t)p][(size_t)k] = idxOut;
        polyOutCorner[(size_t)p][(size_t)k] = idxOut;
      }
    }

    return SplitMesh{std::move(outPos), std::move(outFaces), std::move(polyOutCorner)};
  }

  std::vector<std::vector<int>> buildAdjacencyVec(const std::vector<std::vector<int>>& outFaces, int nV_out) {
    std::vector<std::vector<int>> adj((size_t)nV_out);

    for (auto& v : adj) v.reserve(8); // estimate average valence

    std::vector<int> stamp((size_t)nV_out, -1);
    int curStamp = 0;

    auto addUnique = [&](int a, int b) {
      if (a == b) return;
      if (stamp[(size_t)b] != curStamp) {
        stamp[(size_t)b] = curStamp;
        adj[(size_t)a].push_back(b);
      }
    };

    for (const auto& face : outFaces) {
      int fv = (int)face.size();
      for (int i = 0; i < fv; ++i) {
        int a = face[(size_t)i];
        int b = face[(size_t)((i + 1) % fv)];

        curStamp++;
        addUnique(a, b);
        curStamp++;
        addUnique(b, a);
      }
    }

    return adj;
  }

  static inline Eigen::Vector2d getUV(const tinyobj::attrib_t& attrib, int vt, int nVT_in) {
    if (vt < 0 || vt >= nVT_in) return Eigen::Vector2d(0, 0);
    return toV2(attrib.texcoords, vt);
  }

  static inline int outIndexForTriCorner(const std::vector<std::vector<int>>& polyOutCorner, const Tri& t, int corner) {
    const TriCorner* c = (corner == 0) ? &t.c0 : (corner == 1 ? &t.c1 : &t.c2);
    int p = c->poly;
    int k = c->corner;
    if (p < 0 || p >= (int)polyOutCorner.size()) return -1;
    if (k < 0 || k >= (int)polyOutCorner[(size_t)p].size()) return -1;
    return polyOutCorner[(size_t)p][(size_t)k];
  }

  void accumulateNormalsAndTangents(
      const ObjPolys& m,
      const std::vector<Tri>& tris,
      const std::vector<int>& polyIsland,
      const std::vector<UvIsland>& islands,
      char axisSetting,
      const std::vector<Eigen::Vector3d>& triN,
      const std::vector<double>& triA,
      const std::vector<std::vector<int>>& polyOutCorner,
      int nV_out,
      std::vector<Eigen::Vector3d>& vNormal,
      std::vector<Eigen::Vector3d>& vTangent,
      std::vector<double>& vWeight
  ) {
    const auto& attrib = m.attrib;

    vNormal.assign((size_t)nV_out, Eigen::Vector3d(0, 0, 0));
    vTangent.assign((size_t)nV_out, Eigen::Vector3d(0, 0, 0));
    vWeight.assign((size_t)nV_out, 0.0);

    for (size_t ti = 0; ti < tris.size(); ++ti) {
      const Tri& t = tris[ti];
      const double area = triA[ti];
      const Eigen::Vector3d& n = triN[ti];
      if (area <= 0.0 || n.squaredNorm() < 1e-24) continue;

      int ov0 = outIndexForTriCorner(polyOutCorner, t, 0);
      int ov1 = outIndexForTriCorner(polyOutCorner, t, 1);
      int ov2 = outIndexForTriCorner(polyOutCorner, t, 2);
      if (ov0 < 0 || ov1 < 0 || ov2 < 0) continue;

      vNormal[(size_t)ov0] += area * n;
      vNormal[(size_t)ov1] += area * n;
      vNormal[(size_t)ov2] += area * n;

      const int vt0 = t.c0.idx.texcoord_index;
      const int vt1 = t.c1.idx.texcoord_index;
      const int vt2 = t.c2.idx.texcoord_index;
      if (vt0 < 0 || vt1 < 0 || vt2 < 0 || vt0 >= m.nVT_in || vt1 >= m.nVT_in || vt2 >= m.nVT_in) continue;

      const int v0 = t.v0(), v1 = t.v1(), v2 = t.v2();
      if (v0 < 0 || v1 < 0 || v2 < 0) continue;
      if (v0 >= m.nV_in || v1 >= m.nV_in || v2 >= m.nV_in) continue;

      const Eigen::Vector3d p0 = toV3(attrib.vertices, v0);
      const Eigen::Vector3d p1 = toV3(attrib.vertices, v1);
      const Eigen::Vector3d p2 = toV3(attrib.vertices, v2);

      const Eigen::Vector2d w0 = getUV(attrib, vt0, m.nVT_in);
      const Eigen::Vector2d w1 = getUV(attrib, vt1, m.nVT_in);
      const Eigen::Vector2d w2 = getUV(attrib, vt2, m.nVT_in);

      const Eigen::Vector3d e1 = p1 - p0;
      const Eigen::Vector3d e2 = p2 - p0;
      const Eigen::Vector2d d1 = w1 - w0;
      const Eigen::Vector2d d2 = w2 - w0;

      const double denom = d1.x() * d2.y() - d2.x() * d1.y();
      if (std::abs(denom) < 1e-20) continue;

      const double r = 1.0 / denom;
      const Eigen::Vector3d dPdu = (e1 * d2.y() - e2 * d1.y()) * r;
      const Eigen::Vector3d dPdv = (e2 * d1.x() - e1 * d2.x()) * r;

      char usedAxis = axisSetting;
      if (axisSetting == 'A') {
        const int polyId = t.c0.poly;
        const int iid = (polyId >= 0 && polyId < (int)polyIsland.size()) ? polyIsland[(size_t)polyId] : -1;
        usedAxis = (iid >= 0 && iid < (int)islands.size()) ? islands[(size_t)iid].chosenAxis : 'V';
      }

      Eigen::Vector3d tdir = (usedAxis == 'U') ? dPdu : dPdv;
      tdir = safeNormalize(projectToTangent(tdir, n));
      if (tdir.squaredNorm() < 1e-24) continue;

      const auto add = [&](int ov) {
        Eigen::Vector3d& acc = vTangent[(size_t)ov];
        if (acc.squaredNorm() > 1e-24 && acc.dot(tdir) < 0.0)
          acc -= area * tdir;
        else
          acc += area * tdir;
        vWeight[(size_t)ov] += area;
      };

      add(ov0);
      add(ov1);
      add(ov2);
    }
  }

  std::vector<Eigen::Vector3d> buildFlowFromAccum(
      const std::vector<Eigen::Vector3d>& vNormal,
      const std::vector<Eigen::Vector3d>& vTangent,
      const std::vector<double>& vWeight,
      const std::vector<std::vector<int>>& adj
  ) {
    const int n = (int)vNormal.size();
    std::vector<Eigen::Vector3d> flow((size_t)n, Eigen::Vector3d(0, 0, 0));

    auto normalFor = [&](int v) {
      Eigen::Vector3d nrm = safeNormalize(vNormal[(size_t)v]);
      if (nrm.squaredNorm() < 1e-24) nrm = Eigen::Vector3d(0, 1, 0);
      return nrm;
    };

    for (int v = 0; v < n; ++v) {
      const Eigen::Vector3d nrm = normalFor(v);
      Eigen::Vector3d t = (vWeight[(size_t)v] > 0.0)
          ? (vTangent[(size_t)v] / vWeight[(size_t)v])
          : Eigen::Vector3d(0, 0, 0);
      flow[(size_t)v] = safeNormalize(projectToTangent(t, nrm));
    }

    auto isValid = [&](int v) { return flow[(size_t)v].squaredNorm() > 1e-12; };

    std::vector<uint8_t> visited((size_t)n, 0);
    std::vector<int> q;
    q.reserve(512);

    for (int start = 0; start < n; ++start) {
      if (visited[(size_t)start]) continue;

      q.clear();
      q.push_back(start);
      visited[(size_t)start] = 1;

      std::vector<int> comp;
      comp.reserve(256);

      for (size_t i = 0; i < q.size(); ++i) {
        const int v = q[i];
        comp.push_back(v);
        for (int nb : adj[(size_t)v]) {
          if (!visited[(size_t)nb]) {
            visited[(size_t)nb] = 1;
            q.push_back(nb);
          }
        }
      }

      int anchor = -1;
      double bestW = -1.0;
      for (int v : comp) {
        if (!isValid(v)) continue;
        const double w = vWeight[(size_t)v];
        if (w > bestW) {
          bestW = w;
          anchor = v;
        }
      }

      if (anchor >= 0) {
        std::vector<int8_t> sign((size_t)n, 0);

        std::queue<int> bfs;
        bfs.push(anchor);
        sign[(size_t)anchor] = +1;

        while (!bfs.empty()) {
          const int v = bfs.front();
          bfs.pop();

          if (!isValid(v)) continue;
          const Eigen::Vector3d tv = (double)sign[(size_t)v] * flow[(size_t)v];

          for (int nb : adj[(size_t)v]) {
            if (sign[(size_t)nb] != 0) continue;
            if (!isValid(nb)) continue;

            sign[(size_t)nb] = (tv.dot(flow[(size_t)nb]) >= 0.0) ? +1 : -1;
            bfs.push(nb);
          }
        }

        for (int v : comp) {
          if (sign[(size_t)v] != 0) flow[(size_t)v] = (double)sign[(size_t)v] * flow[(size_t)v];
        }
      }

      constexpr int fillPasses = 6;
      for (int pass = 0; pass < fillPasses; ++pass) {
        int changed = 0;
        for (int v : comp) {
          if (isValid(v)) continue;

          const Eigen::Vector3d nrm = normalFor(v);

          Eigen::Vector3d acc(0, 0, 0);
          int cnt = 0;
          for (int nb : adj[(size_t)v]) {
            if (!isValid(nb)) continue;
            acc += flow[(size_t)nb];
            cnt++;
          }

          if (cnt <= 0) continue;

          const Eigen::Vector3d t = safeNormalize(projectToTangent(acc, nrm));
          if (t.squaredNorm() < 1e-24) continue;

          flow[(size_t)v] = t;
          changed++;
        }
        if (changed == 0) break;
      }

      for (int v : comp) {
        if (isValid(v)) continue;

        const Eigen::Vector3d nrm = normalFor(v);

        Eigen::Vector3d ref(1, 0, 0);
        if (std::abs(nrm.dot(ref)) > 0.99) ref = Eigen::Vector3d(0, 1, 0);

        flow[(size_t)v] = safeNormalize(projectToTangent(ref, nrm));
      }
    }

    return flow;
  }

  void packInterleavedVertices(
      const std::vector<Eigen::Vector3d>& outPos,
      const std::vector<Eigen::Vector3d>& outFlow,
      std::vector<float>& outVert
  ) {
    const int nV_out = (int)outPos.size();
    outVert.clear();
    outVert.reserve((size_t)nV_out * 6);

    for (int i = 0; i < nV_out; ++i) {
      const auto& p = outPos[(size_t)i];
      const auto& t = outFlow[(size_t)i];

      outVert.push_back((float)p.x());
      outVert.push_back((float)p.y());
      outVert.push_back((float)p.z());
      outVert.push_back((float)t.x());
      outVert.push_back((float)t.y());
      outVert.push_back((float)t.z());
    }
  }

  void packTriangleIndices(const std::vector<std::vector<int>>& polyOutCorner, std::vector<unsigned int>& outInd) {
    outInd.clear();

    size_t approx = 0;
    for (const auto& f : polyOutCorner) {
      if (f.size() >= 3) approx += (f.size() - 2) * 3;
    }
    outInd.reserve(approx);

    for (int p = 0; p < (int)polyOutCorner.size(); ++p) {
      const auto& face = polyOutCorner[(size_t)p];
      int fv = (int)face.size();
      if (fv < 3) continue;
      for (int i = 1; i < fv - 1; ++i) {
        outInd.push_back((unsigned int)face[0]);
        outInd.push_back((unsigned int)face[(size_t)i]);
        outInd.push_back((unsigned int)face[(size_t)(i + 1)]);
      }
    }
  }

} // namespace flowfield::detail
