// This code is generated by AI
#include "flowfield_detail.hpp"

#include <algorithm>
#include <cmath>
#include <cstdint>
#include <iostream>
#include <queue>

namespace flowfield::detail {

  // --------------------- small math utils ---------------------

  double deg2rad(double d) {
    return d * M_PI / 180.0;
  }

  // Bounds-checked to avoid UB if indices are bad; returns zero vector on invalid access.
  // (Fast in practice; branch highly predictable. You can switch to assert in release if desired.)
  Eigen::Vector3d toV3(const std::vector<tinyobj::real_t>& a, int i) {
    if (i < 0) return Eigen::Vector3d(0, 0, 0);
    const size_t base = (size_t)3 * (size_t)i;
    if (base + 2 >= a.size()) return Eigen::Vector3d(0, 0, 0);
    return Eigen::Vector3d((double)a[base + 0], (double)a[base + 1], (double)a[base + 2]);
  }
  Eigen::Vector2d toV2(const std::vector<tinyobj::real_t>& a, int i) {
    if (i < 0) return Eigen::Vector2d(0, 0);
    const size_t base = (size_t)2 * (size_t)i;
    if (base + 1 >= a.size()) return Eigen::Vector2d(0, 0);
    return Eigen::Vector2d((double)a[base + 0], (double)a[base + 1]);
  }

  Eigen::Vector3d safeNormalize(const Eigen::Vector3d& v, double eps) {
    double n = v.norm();
    return (n < eps) ? Eigen::Vector3d(0, 0, 0) : v / n;
  }
  Eigen::Vector3d projectToTangent(const Eigen::Vector3d& v, const Eigen::Vector3d& n) {
    return v - v.dot(n) * n;
  }
  double clampd(double x, double a, double b) {
    return std::max(a, std::min(b, x));
  }

  // --------------------- hash keys ---------------------

  std::size_t EdgeKeyHash::operator()(const EdgeKey& k) const noexcept {
    uint64_t a = (uint32_t)k.a;
    uint64_t b = (uint32_t)k.b;
    uint64_t x = (a << 32) ^ b;
    x ^= (x >> 33);
    x *= 0xff51afd7ed558ccdULL;
    x ^= (x >> 33);
    x *= 0xc4ceb9fe1a85ec53ULL;
    x ^= (x >> 33);
    return (size_t)x;
  }

  std::size_t SplitKeyHash::operator()(const SplitKey& k) const noexcept {
    uint64_t a = (uint32_t)k.v;
    uint64_t b = (uint32_t)(k.vt + 1);
    uint64_t c = (uint32_t)k.sg;
    uint64_t x = (a * 1315423911ULL) ^ (b * 2654435761ULL) ^ (c * 97531ULL);
    x ^= (x >> 33);
    x *= 0xff51afd7ed558ccdULL;
    x ^= (x >> 33);
    x *= 0xc4ceb9fe1a85ec53ULL;
    x ^= (x >> 33);
    return (size_t)x;
  }

  std::size_t PairHash::operator()(const std::pair<int, int>& p) const noexcept {
    return std::hash<int>()(p.first) ^ (std::hash<int>()(p.second) << 1);
  }

  // --------------------- Obj loading ---------------------

  bool loadObjAsPolys(const std::string& objPath, ObjPolys& out) {
    tinyobj::ObjReaderConfig cfg;
    cfg.triangulate = false;

    tinyobj::ObjReader reader;
    if (!reader.ParseFromFile(objPath, cfg)) {
      std::cerr << "Failed to read OBJ: " << objPath << "\n";
      return false;
    }

    // COPY attrib so it stays valid after this function returns
    out.attrib = reader.GetAttrib();
    const auto& shapes = reader.GetShapes();

    out.nV_in = (int)(out.attrib.vertices.size() / 3);
    out.nVT_in = (int)(out.attrib.texcoords.size() / 2);

    if (out.nV_in <= 0 || out.nVT_in <= 0) {
      std::cerr << "OBJ must have positions and texcoords\n";
      return false;
    }

    out.polys.clear();
    out.polys.reserve(shapes.size() * 16); // heuristic

    for (const auto& sh : shapes) {
      size_t index_offset = 0;
      for (size_t f = 0; f < sh.mesh.num_face_vertices.size(); f++) {
        int fv = sh.mesh.num_face_vertices[f];
        if (fv < 3) {
          index_offset += (size_t)fv;
          continue;
        }
        std::vector<tinyobj::index_t> poly;
        poly.reserve((size_t)fv);
        for (int k = 0; k < fv; k++) poly.push_back(sh.mesh.indices[index_offset + (size_t)k]);
        out.polys.push_back(std::move(poly));
        index_offset += (size_t)fv;
      }
    }

    return true;
  }

  int getVT(const tinyobj::index_t& idx, int nVT_in) {
    int vt = idx.texcoord_index;
    if (vt < 0 || vt >= nVT_in) return -1;
    return vt;
  }

  // --------------------- UV neighbors/islands ---------------------

  // Performance:
  // - avoid per-edge find_if scans by building per-face map vertex->vt once
  static std::vector<std::unordered_map<int, int>> buildFaceVertexToVt(const ObjPolys& m) {
    std::vector<std::unordered_map<int, int>> map(m.polys.size());
    for (size_t p = 0; p < m.polys.size(); ++p) {
      const auto& poly = m.polys[p];
      auto& mp = map[p];
      mp.reserve(poly.size());
      for (const auto& idx : poly) {
        mp[idx.vertex_index] = getVT(idx, m.nVT_in);
      }
    }
    return map;
  }

  std::vector<std::vector<int>> buildUvNeighbors(const ObjPolys& m) {
    std::vector<std::vector<int>> polyNeighbors(m.polys.size());

    // reserve a rough upper bound: each face has ~3-4 edges
    std::unordered_map<std::pair<int, int>, int, PairHash> edgeToFace;
    edgeToFace.reserve(m.polys.size() * 4);

    const auto faceVt = buildFaceVertexToVt(m);

    for (int p = 0; p < (int)m.polys.size(); ++p) {
      const auto& poly = m.polys[(size_t)p];
      int fv = (int)poly.size();
      for (int i = 0; i < fv; ++i) {
        int vA = poly[(size_t)i].vertex_index;
        int vB = poly[(size_t)((i + 1) % fv)].vertex_index;
        auto ekey = (vA <= vB) ? std::make_pair(vA, vB) : std::make_pair(vB, vA);

        auto it = edgeToFace.find(ekey);
        if (it == edgeToFace.end()) {
          edgeToFace.emplace(ekey, p);
          continue;
        }

        int nb = it->second;

        // seam check: both endpoints must have identical vt on both faces
        const auto& mpA = faceVt[(size_t)p];
        const auto& mpB = faceVt[(size_t)nb];

        auto ita0 = mpA.find(vA);
        auto ita1 = mpA.find(vB);
        auto itb0 = mpB.find(vA);
        auto itb1 = mpB.find(vB);

        if (ita0 == mpA.end() || ita1 == mpA.end() || itb0 == mpB.end() || itb1 == mpB.end()) continue;

        if (ita0->second == itb0->second && ita1->second == itb1->second) {
          polyNeighbors[(size_t)p].push_back(nb);
          polyNeighbors[(size_t)nb].push_back(p);
        }
      }
    }

    return polyNeighbors;
  }

  std::vector<int> computeFaceIslandsBfs(const std::vector<std::vector<int>>& neighbors) {
    std::vector<int> polyIsland(neighbors.size(), -1);
    int nextId = 0;

    for (int start = 0; start < (int)neighbors.size(); ++start) {
      if (polyIsland[(size_t)start] != -1) continue;

      std::queue<int> q;
      q.push(start);
      polyIsland[(size_t)start] = nextId;

      while (!q.empty()) {
        int f = q.front();
        q.pop();
        for (int nb : neighbors[(size_t)f]) {
          if (polyIsland[(size_t)nb] == -1) {
            polyIsland[(size_t)nb] = nextId;
            q.push(nb);
          }
        }
      }
      nextId++;
    }

    return polyIsland;
  }

  std::vector<UvIsland> scoreIslandsAxis(const ObjPolys& m, const std::vector<int>& polyIsland) {
    int islandCount = 0;
    for (int id : polyIsland) islandCount = std::max(islandCount, id + 1);

    std::vector<UvIsland> islands((size_t)islandCount);
    for (int f = 0; f < (int)polyIsland.size(); ++f) {
      int iid = polyIsland[(size_t)f];
      if (iid >= 0) islands[(size_t)iid].faceIds.push_back(f);
    }

    const auto& attrib = m.attrib;

    for (auto& isl : islands) {
      Eigen::Vector3d sumU = Eigen::Vector3d::Zero(), sumV = Eigen::Vector3d::Zero();
      double sumUlen = 0.0, sumVlen = 0.0;

      for (int faceid : isl.faceIds) {
        const auto& poly = m.polys[(size_t)faceid];
        int fv = (int)poly.size();

        // Fan triangulation for scoring
        for (int i = 1; i < fv - 1; ++i) {
          int v[3], vt[3];
          v[0] = poly[0].vertex_index;
          vt[0] = getVT(poly[0], m.nVT_in);
          v[1] = poly[(size_t)i].vertex_index;
          vt[1] = getVT(poly[(size_t)i], m.nVT_in);
          v[2] = poly[(size_t)(i + 1)].vertex_index;
          vt[2] = getVT(poly[(size_t)(i + 1)], m.nVT_in);

          if (v[0] < 0 || v[1] < 0 || v[2] < 0 || vt[0] < 0 || vt[1] < 0 || vt[2] < 0) continue;
          if (v[0] >= m.nV_in || v[1] >= m.nV_in || v[2] >= m.nV_in) continue;

          Eigen::Vector3d p0 = toV3(attrib.vertices, v[0]);
          Eigen::Vector3d p1 = toV3(attrib.vertices, v[1]);
          Eigen::Vector3d p2 = toV3(attrib.vertices, v[2]);

          Eigen::Vector3d n = (p1 - p0).cross(p2 - p0);
          if (n.norm() < 1e-8) continue;
          n.normalize();

          Eigen::Vector2d w0 = toV2(attrib.texcoords, vt[0]);
          Eigen::Vector2d w1 = toV2(attrib.texcoords, vt[1]);
          Eigen::Vector2d w2 = toV2(attrib.texcoords, vt[2]);

          Eigen::Vector3d e1 = p1 - p0, e2 = p2 - p0;
          Eigen::Vector2d d1 = w1 - w0, d2 = w2 - w0;

          double denom = d1.x() * d2.y() - d2.x() * d1.y();
          if (std::abs(denom) < 1e-20) continue;

          double r = 1.0 / denom;
          Eigen::Vector3d dPdu = (e1 * d2.y() - e2 * d1.y()) * r;
          Eigen::Vector3d dPdv = (e2 * d1.x() - e1 * d2.x()) * r;

          dPdu = projectToTangent(dPdu, n);
          dPdv = projectToTangent(dPdv, n);

          double ulen = dPdu.norm();
          double vlen = dPdv.norm();

          if (ulen > 1e-8) {
            sumU += dPdu;
            sumUlen += ulen;
          }
          if (vlen > 1e-8) {
            sumV += dPdv;
            sumVlen += vlen;
          }
        }
      }

      isl.avgU = (sumUlen > 1e-8) ? Eigen::Vector3d(sumU / sumUlen) : Eigen::Vector3d::Zero();
      isl.avgV = (sumVlen > 1e-8) ? Eigen::Vector3d(sumV / sumVlen) : Eigen::Vector3d::Zero();
      isl.chosenAxis = (sumUlen > sumVlen) ? 'U' : 'V';
    }

    return islands;
  }

  // --------------------- triangulation, normals, crease edges ---------------------

  std::vector<Tri> triangulate(const ObjPolys& m) {
    std::vector<Tri> tris;

    // reserve approx: each poly with fv contributes (fv-2) triangles; assume avg 2 triangles
    tris.reserve(m.polys.size() * 2);

    for (int p = 0; p < (int)m.polys.size(); ++p) {
      const auto& poly = m.polys[(size_t)p];
      int fv = (int)poly.size();
      for (int i = 1; i < fv - 1; ++i) {
        Tri t;
        t.c0 = {poly[0], p, 0};
        t.c1 = {poly[(size_t)i], p, i};
        t.c2 = {poly[(size_t)(i + 1)], p, i + 1};
        tris.push_back(t);
      }
    }
    return tris;
  }

  void computeTriNormalsAndAreas(
      const ObjPolys& m, const std::vector<Tri>& tris, std::vector<Eigen::Vector3d>& triN, std::vector<double>& triA
  ) {
    const auto& attrib = m.attrib;
    triN.resize(tris.size());
    triA.resize(tris.size());

    for (size_t ti = 0; ti < tris.size(); ++ti) {
      const Tri& t = tris[ti];
      if (t.v0() < 0 || t.v1() < 0 || t.v2() < 0 || t.v0() >= m.nV_in || t.v1() >= m.nV_in || t.v2() >= m.nV_in) {
        triN[ti] = Eigen::Vector3d(0, 0, 0);
        triA[ti] = 0.0;
        continue;
      }

      Eigen::Vector3d p0 = toV3(attrib.vertices, t.v0());
      Eigen::Vector3d p1 = toV3(attrib.vertices, t.v1());
      Eigen::Vector3d p2 = toV3(attrib.vertices, t.v2());

      Eigen::Vector3d nraw = (p1 - p0).cross(p2 - p0);
      double dblA = nraw.norm();
      if (dblA < 1e-20) {
        triN[ti] = Eigen::Vector3d(0, 0, 0);
        triA[ti] = 0.0;
        continue;
      }

      triN[ti] = nraw / dblA;
      triA[ti] = 0.5 * dblA;
    }
  }

  std::unordered_map<EdgeKey, std::pair<int, int>, EdgeKeyHash> buildEdgeToTris(const std::vector<Tri>& tris) {
    std::unordered_map<EdgeKey, std::pair<int, int>, EdgeKeyHash> edgeToTris;
    edgeToTris.reserve(tris.size() * 2);

    auto add = [&](int ti, int a, int b) {
      EdgeKey ek{std::min(a, b), std::max(a, b)};
      auto it = edgeToTris.find(ek);
      if (it == edgeToTris.end()) {
        edgeToTris.emplace(ek, std::make_pair(ti, -1));
        return;
      }
      if (it->second.second == -1) it->second.second = ti;
    };

    for (int ti = 0; ti < (int)tris.size(); ++ti) {
      const Tri& t = tris[(size_t)ti];
      add(ti, t.v0(), t.v1());
      add(ti, t.v1(), t.v2());
      add(ti, t.v2(), t.v0());
    }

    return edgeToTris;
  }

  std::unordered_set<EdgeKey, EdgeKeyHash> computeCreaseEdges(
      const std::unordered_map<EdgeKey, std::pair<int, int>, EdgeKeyHash>& edgeToTris,
      const std::vector<Eigen::Vector3d>& triN,
      double creaseThresholdAngleDeg
  ) {
    std::unordered_set<EdgeKey, EdgeKeyHash> creaseEdges;
    if (creaseThresholdAngleDeg <= 0.0) return creaseEdges;

    creaseEdges.reserve(edgeToTris.size() / 2);

    double thresh = deg2rad(creaseThresholdAngleDeg);

    for (const auto& kv : edgeToTris) {
      const EdgeKey& e = kv.first;
      int t0 = kv.second.first;
      int t1 = kv.second.second;
      if (t0 < 0 || t1 < 0) continue;

      const Eigen::Vector3d& n0 = triN[(size_t)t0];
      const Eigen::Vector3d& n1 = triN[(size_t)t1];
      if (n0.norm() < 1e-12 || n1.norm() < 1e-12) continue;

      double ang = std::acos(clampd(n0.dot(n1), -1.0, 1.0));
      if (ang > thresh) creaseEdges.insert(e);
    }

    return creaseEdges;
  }

  // --------------------- smoothing groups ---------------------

  void SmoothingHandler::compute(
      int nV_in, const std::vector<Tri>& tris, const std::unordered_set<EdgeKey, EdgeKeyHash>& creaseEdges
  ) {
    vTriToSG.resize((size_t)nV_in);

    std::vector<std::vector<int>> incident((size_t)nV_in);
    for (int ti = 0; ti < (int)tris.size(); ++ti) {
      const Tri& t = tris[(size_t)ti];
      if (t.v0() >= 0) incident[(size_t)t.v0()].push_back(ti);
      if (t.v1() >= 0) incident[(size_t)t.v1()].push_back(ti);
      if (t.v2() >= 0) incident[(size_t)t.v2()].push_back(ti);
    }

    auto isNonCreaseEdgeFromV = [&](int v, int x) {
      EdgeKey ek{std::min(v, x), std::max(v, x)};
      return creaseEdges.find(ek) == creaseEdges.end();
    };

    auto connected = [&](int v, int ta, int tb) -> bool {
      const Tri& A = tris[(size_t)ta];
      const Tri& B = tris[(size_t)tb];

      int an1 = -1, an2 = -1, bn1 = -1, bn2 = -1;

      if (A.v0() == v) {
        an1 = A.v1();
        an2 = A.v2();
      } else if (A.v1() == v) {
        an1 = A.v0();
        an2 = A.v2();
      } else if (A.v2() == v) {
        an1 = A.v0();
        an2 = A.v1();
      } else {
        return false;
      }

      if (B.v0() == v) {
        bn1 = B.v1();
        bn2 = B.v2();
      } else if (B.v1() == v) {
        bn1 = B.v0();
        bn2 = B.v2();
      } else if (B.v2() == v) {
        bn1 = B.v0();
        bn2 = B.v1();
      } else {
        return false;
      }

      if (an1 == bn1 || an1 == bn2) return isNonCreaseEdgeFromV(v, an1);
      if (an2 == bn1 || an2 == bn2) return isNonCreaseEdgeFromV(v, an2);
      return false;
    };

    for (int v = 0; v < nV_in; ++v) {
      const auto& inc = incident[(size_t)v];
      if (inc.empty()) continue;

      auto& triToSg = vTriToSG[(size_t)v];
      triToSg.reserve(inc.size());

      int nextSg = 0;

      for (int tStart : inc) {
        if (triToSg.count(tStart)) continue;

        int sg = nextSg++;
        std::queue<int> q;
        q.push(tStart);
        triToSg[tStart] = sg;

        while (!q.empty()) {
          int ta = q.front();
          q.pop();
          for (int tb : inc) {
            if (triToSg.count(tb)) continue;
            if (connected(v, ta, tb)) {
              triToSg[tb] = sg;
              q.push(tb);
            }
          }
        }
      }
    }
  }

  int SmoothingHandler::getSG(int v, int triIndex) const {
    if (v < 0 || v >= (int)vTriToSG.size()) return 0;
    const auto& m = vTriToSG[(size_t)v];
    auto it = m.find(triIndex);
    if (it == m.end()) return 0;
    return it->second;
  }

  // --------------------- split mesh ---------------------

  SplitMesh buildSplitMesh(
      const ObjPolys& m,
      const std::vector<Tri>& tris,
      const std::unordered_set<EdgeKey, EdgeKeyHash>& creaseEdges,
      double creaseThresholdAngleDeg
  ) {
    const auto& attrib = m.attrib;

    SmoothingHandler sh;
    const bool splitByCrease = (creaseThresholdAngleDeg > 0.0);
    if (splitByCrease) sh.compute(m.nV_in, tris, creaseEdges);

    std::unordered_map<std::pair<int, int>, int, PairHash> cornerToSG; // (polyid,corner)->sg
    if (splitByCrease) {
      cornerToSG.reserve(tris.size() * 2);
      for (size_t ti = 0; ti < tris.size(); ++ti) {
        const Tri& t = tris[ti];
        cornerToSG[{t.c0.poly, t.c0.corner}] = sh.getSG(t.v0(), (int)ti);
        cornerToSG[{t.c1.poly, t.c1.corner}] = sh.getSG(t.v1(), (int)ti);
        cornerToSG[{t.c2.poly, t.c2.corner}] = sh.getSG(t.v2(), (int)ti);
      }
    }

    std::unordered_map<SplitKey, int, SplitKeyHash> splitMap;
    splitMap.reserve(m.polys.size() * 3);

    std::vector<Eigen::Vector3d> outPos;
    outPos.reserve(m.polys.size() * 3);

    std::vector<std::vector<int>> outFaces(m.polys.size());
    std::vector<std::vector<int>> polyOutCorner(m.polys.size());

    auto getOrCreateOut = [&](int vin, int vt, int sg) {
      SplitKey key{vin, vt, sg};
      auto it = splitMap.find(key);
      if (it != splitMap.end()) return it->second;
      int idx = (int)outPos.size();
      outPos.push_back(toV3(attrib.vertices, vin));
      splitMap.emplace(key, idx);
      return idx;
    };

    for (int p = 0; p < (int)m.polys.size(); ++p) {
      const auto& poly = m.polys[(size_t)p];
      int fv = (int)poly.size();
      outFaces[(size_t)p].resize((size_t)fv);
      polyOutCorner[(size_t)p].resize((size_t)fv);

      for (int k = 0; k < fv; ++k) {
        const tinyobj::index_t& idx = poly[(size_t)k];
        int vin = idx.vertex_index;
        int vt = getVT(idx, m.nVT_in);
        int sg = 0;
        if (splitByCrease) {
          auto it = cornerToSG.find({p, k});
          sg = (it != cornerToSG.end()) ? it->second : 0;
        }
        int idxOut = getOrCreateOut(vin, vt, sg);
        outFaces[(size_t)p][(size_t)k] = idxOut;
        polyOutCorner[(size_t)p][(size_t)k] = idxOut;
      }
    }

    return SplitMesh{std::move(outPos), std::move(outFaces), std::move(polyOutCorner)};
  }

  // PERFORMANCE: vector-based adjacency instead of unordered_set.
  // We avoid duplicates by using a per-vertex stamp array.
  std::vector<std::vector<int>> buildAdjacencyVec(const std::vector<std::vector<int>>& outFaces, int nV_out) {
    std::vector<std::vector<int>> adj((size_t)nV_out);

    // Estimate average valence ~6; reserve small.
    for (auto& v : adj) v.reserve(8);

    std::vector<int> stamp((size_t)nV_out, -1);
    int curStamp = 0;

    auto addUnique = [&](int a, int b) {
      if (a == b) return;
      // mark b in a's list
      if (stamp[(size_t)b] != curStamp) {
        stamp[(size_t)b] = curStamp;
        adj[(size_t)a].push_back(b);
      }
    };

    for (const auto& face : outFaces) {
      int fv = (int)face.size();
      for (int i = 0; i < fv; ++i) {
        int a = face[(size_t)i];
        int b = face[(size_t)((i + 1) % fv)];

        // add a<->b without duplicates
        curStamp++;
        addUnique(a, b);
        curStamp++;
        addUnique(b, a);
      }
    }

    return adj;
  }

  // --------------------- tangents/flow ---------------------

  static inline Eigen::Vector2d getUV(const tinyobj::attrib_t& attrib, int vt, int nVT_in) {
    if (vt < 0 || vt >= nVT_in) return Eigen::Vector2d(0, 0);
    return toV2(attrib.texcoords, vt);
  }

  static inline int outIndexForTriCorner(const std::vector<std::vector<int>>& polyOutCorner, const Tri& t, int corner) {
    const TriCorner* c = (corner == 0) ? &t.c0 : (corner == 1 ? &t.c1 : &t.c2);
    int p = c->poly;
    int k = c->corner;
    if (p < 0 || p >= (int)polyOutCorner.size()) return -1;
    if (k < 0 || k >= (int)polyOutCorner[(size_t)p].size()) return -1;
    return polyOutCorner[(size_t)p][(size_t)k];
  }

  void accumulateNormalsAndTangents(
      const ObjPolys& m,
      const std::vector<Tri>& tris,
      const std::vector<int>& polyIsland,
      const std::vector<UvIsland>& islands,
      char axisSetting,
      const std::vector<Eigen::Vector3d>& triN,
      const std::vector<double>& triA,
      const std::vector<std::vector<int>>& polyOutCorner,
      std::vector<Eigen::Vector3d>& vNormal,
      std::vector<Eigen::Vector3d>& vTangent,
      std::vector<double>& vWeight
  ) {
    const auto& attrib = m.attrib;

    int nV_out = 0;
    for (const auto& f : polyOutCorner) {
      for (int idx : f) nV_out = std::max(nV_out, idx + 1);
    }

    vNormal.assign((size_t)nV_out, Eigen::Vector3d(0, 0, 0));
    vTangent.assign((size_t)nV_out, Eigen::Vector3d(0, 0, 0));
    vWeight.assign((size_t)nV_out, 0.0);

    for (size_t ti = 0; ti < tris.size(); ++ti) {
      const Tri& t = tris[ti];
      double area = triA[ti];
      const Eigen::Vector3d& n = triN[ti];
      if (area <= 0.0 || n.norm() < 1e-12) continue;

      int ov0 = outIndexForTriCorner(polyOutCorner, t, 0);
      int ov1 = outIndexForTriCorner(polyOutCorner, t, 1);
      int ov2 = outIndexForTriCorner(polyOutCorner, t, 2);
      if (ov0 < 0 || ov1 < 0 || ov2 < 0) continue;

      vNormal[(size_t)ov0] += area * n;
      vNormal[(size_t)ov1] += area * n;
      vNormal[(size_t)ov2] += area * n;

      int vt0 = t.c0.idx.texcoord_index;
      int vt1 = t.c1.idx.texcoord_index;
      int vt2 = t.c2.idx.texcoord_index;
      if (vt0 < 0 || vt1 < 0 || vt2 < 0 || vt0 >= m.nVT_in || vt1 >= m.nVT_in || vt2 >= m.nVT_in) continue;

      int v0 = t.v0(), v1 = t.v1(), v2 = t.v2();
      if (v0 < 0 || v1 < 0 || v2 < 0) continue;
      if (v0 >= m.nV_in || v1 >= m.nV_in || v2 >= m.nV_in) continue;

      Eigen::Vector3d p0 = toV3(attrib.vertices, v0);
      Eigen::Vector3d p1 = toV3(attrib.vertices, v1);
      Eigen::Vector3d p2 = toV3(attrib.vertices, v2);

      Eigen::Vector2d w0 = getUV(attrib, vt0, m.nVT_in);
      Eigen::Vector2d w1 = getUV(attrib, vt1, m.nVT_in);
      Eigen::Vector2d w2 = getUV(attrib, vt2, m.nVT_in);

      Eigen::Vector3d e1 = p1 - p0, e2 = p2 - p0;
      Eigen::Vector2d d1 = w1 - w0, d2 = w2 - w0;
      double denom = d1.x() * d2.y() - d2.x() * d1.y();
      if (std::abs(denom) < 1e-20) continue;

      double r = 1.0 / denom;
      Eigen::Vector3d dPdu = (e1 * d2.y() - e2 * d1.y()) * r;
      Eigen::Vector3d dPdv = (e2 * d1.x() - e1 * d2.x()) * r;

      char usedAxis = axisSetting;
      if (axisSetting == 'A') {
        int polyId = t.c0.poly;
        int iid = (polyId >= 0 && polyId < (int)polyIsland.size()) ? polyIsland[(size_t)polyId] : -1;
        usedAxis = (iid >= 0 && iid < (int)islands.size()) ? islands[(size_t)iid].chosenAxis : 'V';
      }

      Eigen::Vector3d tdir = (usedAxis == 'U') ? dPdu : dPdv;
      tdir = projectToTangent(tdir, n);
      tdir = safeNormalize(tdir);
      if (tdir.norm() < 1e-12) continue;

      auto accumT = [&](int ov) {
        Eigen::Vector3d cur = vTangent[(size_t)ov];
        if (cur.norm() > 1e-12 && cur.dot(tdir) < 0)
          vTangent[(size_t)ov] += area * (-tdir);
        else
          vTangent[(size_t)ov] += area * tdir;
        vWeight[(size_t)ov] += area;
      };

      accumT(ov0);
      accumT(ov1);
      accumT(ov2);
    }
  }

  std::vector<Eigen::Vector3d> buildFlowFromAccum(
      const std::vector<Eigen::Vector3d>& vNormal,
      const std::vector<Eigen::Vector3d>& vTangent,
      const std::vector<double>& vWeight,
      const std::vector<std::vector<int>>& adj
  ) {
    const int nV_out = (int)vNormal.size();
    std::vector<Eigen::Vector3d> outFlow((size_t)nV_out, Eigen::Vector3d(0, 0, 0));

    // Normalize to tangent plane
    for (int v = 0; v < nV_out; ++v) {
      Eigen::Vector3d t = (vWeight[(size_t)v] > 0.0)
          ? (vTangent[(size_t)v] / vWeight[(size_t)v])
          : Eigen::Vector3d(0, 0, 0);
      Eigen::Vector3d n = safeNormalize(vNormal[(size_t)v]);
      if (n.norm() < 1e-12) n = Eigen::Vector3d(0, 1, 0);
      t = projectToTangent(t, n);
      t = safeNormalize(t);
      outFlow[(size_t)v] = t; // may be zero
    }

    auto isValid = [&](int v) -> bool { return outFlow[(size_t)v].norm() > 1e-6; };

    // 2) For each connected component: choose anchor and propagate a stable sign (+/-1)
    // This removes component-wise random flips and makes results deterministic/object-fixed.
    std::vector<uint8_t> visited((size_t)nV_out, 0);
    std::vector<int8_t> sign((size_t)nV_out, +1);

    std::vector<int> queue;
    queue.reserve(512);

    for (int start = 0; start < nV_out; ++start) {
      if (visited[(size_t)start]) continue;

      // Collect component
      std::vector<int> comp;
      comp.reserve(256);
      queue.clear();
      queue.push_back(start);
      visited[(size_t)start] = 1;

      for (size_t qi = 0; qi < queue.size(); ++qi) {
        int v = queue[qi];
        comp.push_back(v);
        for (int nb : adj[(size_t)v]) {
          if (!visited[(size_t)nb]) {
            visited[(size_t)nb] = 1;
            queue.push_back(nb);
          }
        }
      }

      // Find anchor (valid tangent with max weight)
      int anchor = -1;
      double bestW = -1.0;
      for (int v : comp) {
        if (!isValid(v)) continue;
        double w = vWeight[(size_t)v];
        if (w > bestW) {
          bestW = w;
          anchor = v;
        }
      }

      if (anchor == -1) {
        // No valid vectors in this component; we'll create deterministic dummy vectors later.
        continue;
      }

      // Propagate sign using BFS from anchor
      // We only use already-valid vectors as constraints; zeros are ignored here.
      std::unordered_map<int, uint8_t> inComp; // optional; avoid O(n) lookups? but we already have visited.
      (void)inComp;

      std::vector<uint8_t> seenLocal((size_t)comp.size(), 0); // not directly indexable; keep a map? too heavy
      // Instead: reuse a separate visited2 array with generation stamp to be O(1)
      // We'll implement stamp arrays for speed/determinism:

      static thread_local std::vector<int> stamp;
      static thread_local int gen = 1;
      if ((int)stamp.size() < nV_out) stamp.assign((size_t)nV_out, 0);
      gen++;
      for (int v : comp) stamp[(size_t)v] = gen;

      std::vector<uint8_t> used((size_t)nV_out, 0);
      std::queue<int> q;
      q.push(anchor);
      used[(size_t)anchor] = 1;
      sign[(size_t)anchor] = +1;

      while (!q.empty()) {
        int v = q.front();
        q.pop();
        if (!isValid(v)) continue;

        Eigen::Vector3d tv = (double)sign[(size_t)v] * outFlow[(size_t)v];

        for (int nb : adj[(size_t)v]) {
          if (stamp[(size_t)nb] != gen) continue; // not in this component
          if (used[(size_t)nb]) continue;
          if (!isValid(nb)) continue; // only constrain valid neighbors

          // Choose sign for nb to align with v
          double d = tv.dot(outFlow[(size_t)nb]);
          sign[(size_t)nb] = (d >= 0.0) ? +1 : -1;

          used[(size_t)nb] = 1;
          q.push(nb);
        }
      }

      // Apply sign to all valid vertices that got assigned through the BFS.
      // Vertices that are valid but were not reached via "valid-valid" connections keep default sign +1;
      // that's still deterministic, and will be handled by later fill/propagation.
      for (int v : comp) {
        if (!isValid(v)) continue;
        outFlow[(size_t)v] = (double)sign[(size_t)v] * outFlow[(size_t)v];
      }
    }

    // 3) Fill zeros (now using stable neighbors; we do NOT do flip-by-acc heuristics anymore)
    constexpr int fillerIterations = 6;
    for (int pass = 0; pass < fillerIterations; ++pass) {
      int changed = 0;
      for (int v = 0; v < nV_out; ++v) {
        if (isValid(v)) continue;

        Eigen::Vector3d n = safeNormalize(vNormal[(size_t)v]);
        if (n.norm() < 1e-12) n = Eigen::Vector3d(0, 1, 0);

        Eigen::Vector3d acc(0, 0, 0);
        int cnt = 0;
        for (int nb : adj[(size_t)v]) {
          if (!isValid(nb)) continue;
          acc += outFlow[(size_t)nb];
          cnt++;
        }

        if (cnt > 0) {
          Eigen::Vector3d t = safeNormalize(projectToTangent(acc, n));
          if (t.norm() > 1e-12) {
            outFlow[(size_t)v] = t;
            changed++;
          }
        }
      }
      if (changed == 0) break;
    }

    // 4) Deterministic fallback for components that are still all-zero
    // (or remaining zeros after iterations): choose a stable tangent from normal (object-fixed).
    // We use a fixed reference axis, with a stable alternative if nearly parallel.
    std::vector<uint8_t> visited3((size_t)nV_out, 0);
    std::vector<int> q2;
    q2.reserve(512);

    for (int start = 0; start < nV_out; ++start) {
      if (visited3[(size_t)start]) continue;

      q2.clear();
      q2.push_back(start);
      visited3[(size_t)start] = 1;

      bool anyValid = isValid(start);
      std::vector<int> comp;
      comp.reserve(256);

      for (size_t qi = 0; qi < q2.size(); ++qi) {
        int v = q2[qi];
        comp.push_back(v);
        for (int nb : adj[(size_t)v]) {
          if (!visited3[(size_t)nb]) {
            visited3[(size_t)nb] = 1;
            q2.push_back(nb);
            anyValid = anyValid || isValid(nb);
          }
        }
      }

      if (anyValid) continue;

      // All-zero component -> assign deterministic dummy tangent
      for (int v : comp) {
        Eigen::Vector3d n = safeNormalize(vNormal[(size_t)v]);
        if (n.norm() < 1e-12) n = Eigen::Vector3d(0, 1, 0);

        Eigen::Vector3d ref(1, 0, 0);
        if (std::abs(n.dot(ref)) > 0.99) ref = Eigen::Vector3d(0, 1, 0);

        outFlow[(size_t)v] = safeNormalize(projectToTangent(ref, n));
      }
    }

    return outFlow;
  }

  // --------------------- packing ---------------------

  void packInterleavedVertices(
      const std::vector<Eigen::Vector3d>& outPos,
      const std::vector<Eigen::Vector3d>& outFlow,
      std::vector<float>& outVert
  ) {
    const int nV_out = (int)outPos.size();
    outVert.clear();
    outVert.reserve((size_t)nV_out * 6);

    for (int i = 0; i < nV_out; ++i) {
      const auto& p = outPos[(size_t)i];
      const auto& t = outFlow[(size_t)i];

      outVert.push_back((float)p.x());
      outVert.push_back((float)p.y());
      outVert.push_back((float)p.z());
      outVert.push_back((float)t.x());
      outVert.push_back((float)t.y());
      outVert.push_back((float)t.z());
    }
  }

  void packTriangleIndices(const std::vector<std::vector<int>>& polyOutCorner, std::vector<unsigned int>& outInd) {
    outInd.clear();

    size_t approx = 0;
    for (const auto& f : polyOutCorner) {
      if (f.size() >= 3) approx += (f.size() - 2) * 3;
    }
    outInd.reserve(approx);

    for (int p = 0; p < (int)polyOutCorner.size(); ++p) {
      const auto& face = polyOutCorner[(size_t)p];
      int fv = (int)face.size();
      if (fv < 3) continue;
      for (int i = 1; i < fv - 1; ++i) {
        outInd.push_back((unsigned int)face[0]);
        outInd.push_back((unsigned int)face[(size_t)i]);
        outInd.push_back((unsigned int)face[(size_t)(i + 1)]);
      }
    }
  }

} // namespace flowfield::detail
